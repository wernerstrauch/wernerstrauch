---
/**
 * ShopifyEcosystemCanvas
 * Animated canvas showing Shopify logo with surrounding ecosystem icons
 *
 * Usage:
 * <ShopifyEcosystemCanvas id="my-shopify-canvas" class="w-full h-64" />
 */
interface Props {
  id: string;
  class?: string;
  accentColor?: string;
}

const { id, class: className = "", accentColor = "#4f3ca2" } = Astro.props;
---

<canvas
  id={id}
  class:list={["shopify-ecosystem-canvas", className]}
  data-accent-color={accentColor}></canvas>

<script>
  interface CanvasState {
    canvas: HTMLCanvasElement;
    ctx: CanvasRenderingContext2D;
    time: number;
    animationId: number | null;
    resizeObserver: ResizeObserver;
    accentColor: string;
  }

  const canvasStates: Map<string, CanvasState> = new Map();

  function drawRoundedRect(
    ctx: CanvasRenderingContext2D,
    x: number,
    y: number,
    w: number,
    h: number,
    r: number,
  ) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
  }

  function drawShopifyLogo(
    ctx: CanvasRenderingContext2D,
    cx: number,
    cy: number,
    size: number,
  ) {
    const scale = size / 100;

    ctx.save();
    ctx.translate(cx - size / 2, cy - size / 2);
    ctx.scale(scale, scale);

    // Bag body
    ctx.beginPath();
    ctx.moveTo(25, 20);
    ctx.lineTo(15, 95);
    ctx.lineTo(85, 95);
    ctx.lineTo(75, 20);
    ctx.closePath();

    const gradient = ctx.createLinearGradient(15, 20, 85, 95);
    gradient.addColorStop(0, "#95BF47");
    gradient.addColorStop(1, "#5E8E3E");
    ctx.fillStyle = gradient;
    ctx.fill();

    // Bag handle
    ctx.beginPath();
    ctx.moveTo(35, 20);
    ctx.quadraticCurveTo(35, 5, 50, 5);
    ctx.quadraticCurveTo(65, 5, 65, 20);
    ctx.strokeStyle = "#95BF47";
    ctx.lineWidth = 6;
    ctx.lineCap = "round";
    ctx.stroke();

    // S letter
    ctx.fillStyle = "white";
    ctx.font = "bold 48px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("S", 50, 60);

    ctx.restore();
  }

  function drawIcon(
    ctx: CanvasRenderingContext2D,
    icon: string,
    cx: number,
    cy: number,
    size: number,
    color: string,
  ) {
    ctx.save();
    ctx.strokeStyle = color;
    ctx.fillStyle = color;
    ctx.lineWidth = 2;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    const s = size * 0.4;

    switch (icon) {
      case "settings": {
        ctx.beginPath();
        const teeth = 8;
        const outerR = s;
        const innerR = s * 0.7;
        for (let i = 0; i < teeth * 2; i++) {
          const r = i % 2 === 0 ? outerR : innerR;
          const angle = (i * Math.PI) / teeth;
          const x = cx + Math.cos(angle) * r;
          const y = cy + Math.sin(angle) * r;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(cx, cy, s * 0.3, 0, Math.PI * 2);
        ctx.stroke();
        break;
      }

      case "sync":
        ctx.beginPath();
        ctx.moveTo(cx - s, cy);
        ctx.lineTo(cx + s * 0.5, cy);
        ctx.moveTo(cx + s * 0.2, cy - s * 0.4);
        ctx.lineTo(cx + s * 0.5, cy);
        ctx.lineTo(cx + s * 0.2, cy + s * 0.4);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(cx + s, cy + s * 0.5);
        ctx.lineTo(cx - s * 0.5, cy + s * 0.5);
        ctx.moveTo(cx - s * 0.2, cy + s * 0.1);
        ctx.lineTo(cx - s * 0.5, cy + s * 0.5);
        ctx.lineTo(cx - s * 0.2, cy + s * 0.9);
        ctx.stroke();
        break;

      case "shop":
        ctx.beginPath();
        ctx.moveTo(cx - s * 0.6, cy - s * 0.2);
        ctx.lineTo(cx - s * 0.8, cy + s);
        ctx.lineTo(cx + s * 0.8, cy + s);
        ctx.lineTo(cx + s * 0.6, cy - s * 0.2);
        ctx.closePath();
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(cx - s * 0.3, cy - s * 0.2);
        ctx.quadraticCurveTo(cx - s * 0.3, cy - s * 0.8, cx, cy - s * 0.8);
        ctx.quadraticCurveTo(
          cx + s * 0.3,
          cy - s * 0.8,
          cx + s * 0.3,
          cy - s * 0.2,
        );
        ctx.stroke();
        break;

      case "check":
        ctx.beginPath();
        ctx.arc(cx, cy, s, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(cx - s * 0.4, cy);
        ctx.lineTo(cx - s * 0.1, cy + s * 0.4);
        ctx.lineTo(cx + s * 0.5, cy - s * 0.3);
        ctx.stroke();
        break;

      case "code":
        ctx.beginPath();
        ctx.moveTo(cx - s * 0.3, cy - s * 0.6);
        ctx.lineTo(cx - s * 0.7, cy);
        ctx.lineTo(cx - s * 0.3, cy + s * 0.6);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(cx + s * 0.3, cy - s * 0.6);
        ctx.lineTo(cx + s * 0.7, cy);
        ctx.lineTo(cx + s * 0.3, cy + s * 0.6);
        ctx.stroke();
        break;

      case "truck":
        ctx.beginPath();
        ctx.rect(cx - s, cy - s * 0.3, s * 1.2, s * 0.8);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(cx + s * 0.2, cy - s * 0.3);
        ctx.lineTo(cx + s * 0.2, cy - s * 0.6);
        ctx.lineTo(cx + s * 0.8, cy - s * 0.6);
        ctx.lineTo(cx + s, cy - s * 0.3);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(cx - s * 0.5, cy + s * 0.5, s * 0.2, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(cx + s * 0.6, cy + s * 0.5, s * 0.2, 0, Math.PI * 2);
        ctx.stroke();
        break;
    }

    ctx.restore();
  }

  function animate(state: CanvasState) {
    const { ctx, canvas, accentColor } = state;
    const rect = canvas.getBoundingClientRect();
    const width = rect.width;
    const height = rect.height;

    state.time += 0.02;

    ctx.clearRect(0, 0, width, height);

    const centerX = width / 2;
    const centerY = height / 2;

    const iconSize = Math.min(width, height) * 0.08;
    const logoSize = Math.min(width, height) * 0.18;
    const spacing = width * 0.18;

    const icons: { icon: string; offsetX: number; phase: number }[] = [
      { icon: "settings", offsetX: -spacing * 2, phase: 0 },
      { icon: "sync", offsetX: -spacing, phase: 0.5 },
      { icon: "shop", offsetX: spacing, phase: 1 },
      { icon: "check", offsetX: spacing * 2, phase: 1.5 },
    ];

    // Draw connecting line
    ctx.strokeStyle = "#95BF47";
    ctx.lineWidth = 2;
    ctx.setLineDash([]);
    ctx.beginPath();
    ctx.moveTo(width * 0.08, centerY);
    ctx.lineTo(width * 0.92, centerY);
    ctx.stroke();

    // Draw icon cards
    icons.forEach(({ icon, offsetX, phase }) => {
      const floatY = Math.sin(state.time + phase) * 6;
      const x = centerX + offsetX;
      const y = centerY + floatY;
      const cardSize = iconSize * 1.8;

      ctx.shadowColor = "rgba(0, 0, 0, 0.1)";
      ctx.shadowBlur = 10;
      ctx.shadowOffsetY = 4;

      ctx.fillStyle = "white";
      drawRoundedRect(
        ctx,
        x - cardSize / 2,
        y - cardSize / 2,
        cardSize,
        cardSize,
        cardSize * 0.2,
      );
      ctx.fill();

      ctx.shadowColor = "transparent";
      ctx.shadowBlur = 0;
      ctx.shadowOffsetY = 0;

      drawIcon(ctx, icon, x, y, iconSize, accentColor);
    });

    // Draw central Shopify card
    const logoFloatY = Math.sin(state.time * 0.8) * 8;
    const logoCardSize = logoSize * 1.3;

    ctx.shadowColor = "rgba(0, 0, 0, 0.15)";
    ctx.shadowBlur = 20;
    ctx.shadowOffsetY = 8;

    ctx.fillStyle = "white";
    drawRoundedRect(
      ctx,
      centerX - logoCardSize / 2,
      centerY + logoFloatY - logoCardSize / 2,
      logoCardSize,
      logoCardSize,
      logoCardSize * 0.15,
    );
    ctx.fill();

    ctx.shadowColor = "transparent";
    ctx.shadowBlur = 0;
    ctx.shadowOffsetY = 0;

    drawShopifyLogo(ctx, centerX, centerY + logoFloatY, logoSize * 0.8);

    state.animationId = requestAnimationFrame(() => animate(state));
  }

  function initCanvas(canvas: HTMLCanvasElement) {
    const id = canvas.id;
    if (!id || canvasStates.has(id)) return;

    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;

    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;

    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    ctx.scale(dpr, dpr);

    const state: CanvasState = {
      canvas,
      ctx,
      time: 0,
      animationId: null,
      accentColor: canvas.dataset.accentColor || "#4f3ca2",
      resizeObserver: new ResizeObserver(() => {
        const newRect = canvas.getBoundingClientRect();
        canvas.width = newRect.width * dpr;
        canvas.height = newRect.height * dpr;
        ctx.scale(dpr, dpr);
      }),
    };

    state.resizeObserver.observe(canvas.parentElement || canvas);
    canvasStates.set(id, state);
    animate(state);
  }

  function initAllCanvases() {
    document
      .querySelectorAll<HTMLCanvasElement>(".shopify-ecosystem-canvas")
      .forEach(initCanvas);
  }

  function cleanup() {
    canvasStates.forEach((state) => {
      if (state.animationId) cancelAnimationFrame(state.animationId);
      state.resizeObserver.disconnect();
    });
    canvasStates.clear();
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initAllCanvases);
  } else {
    initAllCanvases();
  }
  document.addEventListener("astro:after-swap", initAllCanvases);
  document.addEventListener("astro:before-swap", cleanup, { once: true });
</script>

<style>
  .shopify-ecosystem-canvas {
    display: block;
  }
</style>

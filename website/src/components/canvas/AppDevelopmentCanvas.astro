---
/**
 * AppDevelopmentCanvas
 * Animated canvas showing app development visualization with central device and orbiting elements
 *
 * Usage:
 * <AppDevelopmentCanvas id="my-app-canvas" class="w-full h-64" />
 */
interface Props {
  id: string;
  class?: string;
  accentColor?: string;
}

const { id, class: className = "", accentColor = "#4f3ca2" } = Astro.props;
---

<canvas
  id={id}
  class:list={["app-development-canvas", className]}
  data-accent-color={accentColor}></canvas>

<script>
  interface Particle {
    x: number;
    y: number;
    vx: number;
    vy: number;
    size: number;
    alpha: number;
  }

  interface CanvasState {
    canvas: HTMLCanvasElement;
    ctx: CanvasRenderingContext2D;
    time: number;
    animationId: number | null;
    resizeObserver: ResizeObserver;
    accentColor: string;
    particles: Particle[];
  }

  const canvasStates: Map<string, CanvasState> = new Map();

  function drawRoundedRect(
    ctx: CanvasRenderingContext2D,
    x: number,
    y: number,
    w: number,
    h: number,
    r: number,
  ) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
  }

  function drawSmartphone(
    ctx: CanvasRenderingContext2D,
    cx: number,
    cy: number,
    width: number,
    height: number,
    accentColor: string,
  ) {
    const radius = width * 0.15;

    // Phone body shadow
    ctx.shadowColor = "rgba(0, 0, 0, 0.2)";
    ctx.shadowBlur = 20;
    ctx.shadowOffsetY = 10;

    // Phone body
    ctx.fillStyle = "#1a1a2e";
    drawRoundedRect(
      ctx,
      cx - width / 2,
      cy - height / 2,
      width,
      height,
      radius,
    );
    ctx.fill();

    ctx.shadowColor = "transparent";
    ctx.shadowBlur = 0;
    ctx.shadowOffsetY = 0;

    // Screen
    const screenPadding = width * 0.08;
    const screenWidth = width - screenPadding * 2;
    const screenHeight = height - screenPadding * 3;
    const screenX = cx - screenWidth / 2;
    const screenY = cy - height / 2 + screenPadding;

    const gradient = ctx.createLinearGradient(
      screenX,
      screenY,
      screenX + screenWidth,
      screenY + screenHeight,
    );
    gradient.addColorStop(0, accentColor);
    gradient.addColorStop(1, adjustColor(accentColor, -30));

    ctx.fillStyle = gradient;
    drawRoundedRect(
      ctx,
      screenX,
      screenY,
      screenWidth,
      screenHeight,
      radius * 0.6,
    );
    ctx.fill();

    // App grid on screen
    const gridSize = 3;
    const appSize = screenWidth / (gridSize + 1);
    const appSpacing = (screenWidth - appSize * gridSize) / (gridSize + 1);

    for (let row = 0; row < 2; row++) {
      for (let col = 0; col < gridSize; col++) {
        const appX = screenX + appSpacing + col * (appSize + appSpacing);
        const appY =
          screenY + screenHeight * 0.15 + row * (appSize + appSpacing);

        ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
        drawRoundedRect(ctx, appX, appY, appSize, appSize, appSize * 0.2);
        ctx.fill();
      }
    }

    // Home indicator
    ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
    const indicatorWidth = width * 0.35;
    const indicatorHeight = 4;
    drawRoundedRect(
      ctx,
      cx - indicatorWidth / 2,
      cy + height / 2 - screenPadding * 0.7,
      indicatorWidth,
      indicatorHeight,
      2,
    );
    ctx.fill();
  }

  function adjustColor(hex: string, amount: number): string {
    const num = parseInt(hex.replace("#", ""), 16);
    const r = Math.min(255, Math.max(0, (num >> 16) + amount));
    const g = Math.min(255, Math.max(0, ((num >> 8) & 0x00ff) + amount));
    const b = Math.min(255, Math.max(0, (num & 0x0000ff) + amount));
    return `#${((r << 16) | (g << 8) | b).toString(16).padStart(6, "0")}`;
  }

  function drawIcon(
    ctx: CanvasRenderingContext2D,
    icon: string,
    cx: number,
    cy: number,
    size: number,
    color: string,
  ) {
    ctx.save();
    ctx.strokeStyle = color;
    ctx.fillStyle = color;
    ctx.lineWidth = 2;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    const s = size * 0.4;

    switch (icon) {
      case "code": {
        // Code brackets < />
        ctx.beginPath();
        ctx.moveTo(cx - s * 0.5, cy - s * 0.5);
        ctx.lineTo(cx - s, cy);
        ctx.lineTo(cx - s * 0.5, cy + s * 0.5);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(cx + s * 0.5, cy - s * 0.5);
        ctx.lineTo(cx + s, cy);
        ctx.lineTo(cx + s * 0.5, cy + s * 0.5);
        ctx.stroke();
        // Slash
        ctx.beginPath();
        ctx.moveTo(cx + s * 0.2, cy - s * 0.4);
        ctx.lineTo(cx - s * 0.2, cy + s * 0.4);
        ctx.stroke();
        break;
      }

      case "api": {
        // Cloud with connection
        ctx.beginPath();
        ctx.arc(cx - s * 0.3, cy, s * 0.4, Math.PI * 0.5, Math.PI * 1.5);
        ctx.arc(cx, cy - s * 0.3, s * 0.5, Math.PI, Math.PI * 2);
        ctx.arc(cx + s * 0.3, cy, s * 0.4, Math.PI * 1.5, Math.PI * 0.5);
        ctx.lineTo(cx - s * 0.5, cy + s * 0.2);
        ctx.stroke();
        // Arrow down
        ctx.beginPath();
        ctx.moveTo(cx, cy + s * 0.3);
        ctx.lineTo(cx, cy + s * 0.8);
        ctx.moveTo(cx - s * 0.2, cy + s * 0.6);
        ctx.lineTo(cx, cy + s * 0.8);
        ctx.lineTo(cx + s * 0.2, cy + s * 0.6);
        ctx.stroke();
        break;
      }

      case "database": {
        // Database cylinder
        ctx.beginPath();
        ctx.ellipse(cx, cy - s * 0.5, s * 0.6, s * 0.25, 0, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(cx - s * 0.6, cy - s * 0.5);
        ctx.lineTo(cx - s * 0.6, cy + s * 0.3);
        ctx.ellipse(
          cx,
          cy + s * 0.3,
          s * 0.6,
          s * 0.25,
          0,
          Math.PI,
          Math.PI * 2,
        );
        ctx.lineTo(cx + s * 0.6, cy - s * 0.5);
        ctx.stroke();
        // Middle lines
        ctx.beginPath();
        ctx.ellipse(
          cx,
          cy - s * 0.1,
          s * 0.6,
          s * 0.2,
          0,
          Math.PI,
          Math.PI * 2,
        );
        ctx.stroke();
        break;
      }

      case "gear": {
        // Settings gear
        const teeth = 8;
        const outerR = s * 0.8;
        const innerR = s * 0.55;
        ctx.beginPath();
        for (let i = 0; i < teeth * 2; i++) {
          const r = i % 2 === 0 ? outerR : innerR;
          const angle = (i * Math.PI) / teeth;
          const x = cx + Math.cos(angle) * r;
          const y = cy + Math.sin(angle) * r;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(cx, cy, s * 0.25, 0, Math.PI * 2);
        ctx.stroke();
        break;
      }

      case "rocket": {
        // Rocket ship
        ctx.beginPath();
        // Body
        ctx.moveTo(cx, cy - s * 0.8);
        ctx.quadraticCurveTo(
          cx + s * 0.4,
          cy - s * 0.3,
          cx + s * 0.3,
          cy + s * 0.4,
        );
        ctx.lineTo(cx - s * 0.3, cy + s * 0.4);
        ctx.quadraticCurveTo(cx - s * 0.4, cy - s * 0.3, cx, cy - s * 0.8);
        ctx.stroke();
        // Window
        ctx.beginPath();
        ctx.arc(cx, cy - s * 0.2, s * 0.15, 0, Math.PI * 2);
        ctx.stroke();
        // Fins
        ctx.beginPath();
        ctx.moveTo(cx - s * 0.3, cy + s * 0.2);
        ctx.lineTo(cx - s * 0.6, cy + s * 0.5);
        ctx.lineTo(cx - s * 0.3, cy + s * 0.4);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(cx + s * 0.3, cy + s * 0.2);
        ctx.lineTo(cx + s * 0.6, cy + s * 0.5);
        ctx.lineTo(cx + s * 0.3, cy + s * 0.4);
        ctx.stroke();
        break;
      }

      case "puzzle": {
        // Puzzle piece
        const ps = s * 0.7;
        ctx.beginPath();
        ctx.moveTo(cx - ps, cy - ps * 0.5);
        ctx.lineTo(cx - ps * 0.3, cy - ps * 0.5);
        ctx.arc(cx, cy - ps * 0.5, ps * 0.3, Math.PI, 0, true);
        ctx.lineTo(cx + ps, cy - ps * 0.5);
        ctx.lineTo(cx + ps, cy + ps * 0.5);
        ctx.lineTo(cx - ps, cy + ps * 0.5);
        ctx.closePath();
        ctx.stroke();
        break;
      }
    }

    ctx.restore();
  }

  function drawOrbitingElement(
    ctx: CanvasRenderingContext2D,
    cx: number,
    cy: number,
    orbitRadius: number,
    angle: number,
    icon: string,
    iconSize: number,
    accentColor: string,
    floatOffset: number,
  ) {
    const x = cx + Math.cos(angle) * orbitRadius;
    const y = cy + Math.sin(angle) * orbitRadius * 0.5 + floatOffset;
    const cardSize = iconSize * 1.8;

    // Card shadow
    ctx.shadowColor = "rgba(0, 0, 0, 0.1)";
    ctx.shadowBlur = 10;
    ctx.shadowOffsetY = 4;

    // Card background
    ctx.fillStyle = "white";
    drawRoundedRect(
      ctx,
      x - cardSize / 2,
      y - cardSize / 2,
      cardSize,
      cardSize,
      cardSize * 0.2,
    );
    ctx.fill();

    ctx.shadowColor = "transparent";
    ctx.shadowBlur = 0;
    ctx.shadowOffsetY = 0;

    // Icon
    drawIcon(ctx, icon, x, y, iconSize, accentColor);
  }

  function drawConnectionLine(
    ctx: CanvasRenderingContext2D,
    fromX: number,
    fromY: number,
    toX: number,
    toY: number,
    progress: number,
    accentColor: string,
  ) {
    const dx = toX - fromX;
    const dy = toY - fromY;
    const currentX = fromX + dx * progress;
    const currentY = fromY + dy * progress;

    // Dashed line
    ctx.strokeStyle = adjustColor(accentColor, 50);
    ctx.lineWidth = 1.5;
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.moveTo(fromX, fromY);
    ctx.lineTo(toX, toY);
    ctx.stroke();
    ctx.setLineDash([]);

    // Moving dot
    if (progress > 0 && progress < 1) {
      ctx.fillStyle = accentColor;
      ctx.beginPath();
      ctx.arc(currentX, currentY, 4, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function animate(state: CanvasState) {
    const { ctx, canvas, accentColor, particles } = state;
    const rect = canvas.getBoundingClientRect();
    const width = rect.width;
    const height = rect.height;

    state.time += 0.015;

    ctx.clearRect(0, 0, width, height);

    const centerX = width / 2;
    const centerY = height / 2;

    const phoneWidth = Math.min(width, height) * 0.18;
    const phoneHeight = phoneWidth * 2;
    const orbitRadius = Math.min(width, height) * 0.35;
    const iconSize = Math.min(width, height) * 0.07;

    const icons = [
      { icon: "code", phase: 0 },
      { icon: "api", phase: Math.PI * 0.5 },
      { icon: "database", phase: Math.PI },
      { icon: "gear", phase: Math.PI * 1.5 },
    ];

    // Draw orbit path (subtle)
    ctx.strokeStyle = "rgba(0, 0, 0, 0.05)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.ellipse(
      centerX,
      centerY,
      orbitRadius,
      orbitRadius * 0.5,
      0,
      0,
      Math.PI * 2,
    );
    ctx.stroke();

    // Draw connection lines from icons to phone
    icons.forEach(({ phase }, index) => {
      const angle = state.time * 0.3 + phase;
      const x = centerX + Math.cos(angle) * orbitRadius;
      const y = centerY + Math.sin(angle) * orbitRadius * 0.5;
      const progress = (state.time * 0.5 + index * 0.25) % 1;
      drawConnectionLine(ctx, x, y, centerX, centerY, progress, accentColor);
    });

    // Draw orbiting elements (back layer - behind phone)
    icons.slice(2).forEach(({ icon, phase }) => {
      const angle = state.time * 0.3 + phase;
      const floatOffset = Math.sin(state.time * 2 + phase) * 5;
      drawOrbitingElement(
        ctx,
        centerX,
        centerY,
        orbitRadius,
        angle,
        icon,
        iconSize,
        accentColor,
        floatOffset,
      );
    });

    // Draw smartphone (center)
    const phoneFloat = Math.sin(state.time * 0.8) * 6;
    drawSmartphone(
      ctx,
      centerX,
      centerY + phoneFloat,
      phoneWidth,
      phoneHeight,
      accentColor,
    );

    // Draw orbiting elements (front layer - in front of phone)
    icons.slice(0, 2).forEach(({ icon, phase }) => {
      const angle = state.time * 0.3 + phase;
      const floatOffset = Math.sin(state.time * 2 + phase) * 5;
      drawOrbitingElement(
        ctx,
        centerX,
        centerY,
        orbitRadius,
        angle,
        icon,
        iconSize,
        accentColor,
        floatOffset,
      );
    });

    // Draw floating particles
    particles.forEach((p) => {
      p.x += p.vx;
      p.y += p.vy;
      p.alpha -= 0.005;

      if (p.alpha <= 0) {
        // Reset particle
        p.x = centerX + (Math.random() - 0.5) * phoneWidth;
        p.y = centerY + phoneFloat - phoneHeight / 2;
        p.vx = (Math.random() - 0.5) * 0.5;
        p.vy = -Math.random() * 0.8 - 0.2;
        p.alpha = 0.6;
      }

      ctx.fillStyle = `rgba(${hexToRgb(accentColor)}, ${p.alpha})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
    });

    state.animationId = requestAnimationFrame(() => animate(state));
  }

  function hexToRgb(hex: string): string {
    const num = parseInt(hex.replace("#", ""), 16);
    return `${(num >> 16) & 255}, ${(num >> 8) & 255}, ${num & 255}`;
  }

  function initCanvas(canvas: HTMLCanvasElement) {
    const id = canvas.id;
    if (!id || canvasStates.has(id)) return;

    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;

    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;

    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    ctx.scale(dpr, dpr);

    // Initialize particles
    const particles: Particle[] = [];
    for (let i = 0; i < 12; i++) {
      particles.push({
        x: rect.width / 2 + (Math.random() - 0.5) * 50,
        y: rect.height / 2 - 50,
        vx: (Math.random() - 0.5) * 0.5,
        vy: -Math.random() * 0.8 - 0.2,
        size: Math.random() * 2 + 1,
        alpha: Math.random() * 0.6,
      });
    }

    const state: CanvasState = {
      canvas,
      ctx,
      time: 0,
      animationId: null,
      accentColor: canvas.dataset.accentColor || "#4f3ca2",
      particles,
      resizeObserver: new ResizeObserver(() => {
        const newRect = canvas.getBoundingClientRect();
        canvas.width = newRect.width * dpr;
        canvas.height = newRect.height * dpr;
        ctx.scale(dpr, dpr);
      }),
    };

    state.resizeObserver.observe(canvas.parentElement || canvas);
    canvasStates.set(id, state);
    animate(state);
  }

  function initAllCanvases() {
    document
      .querySelectorAll<HTMLCanvasElement>(".app-development-canvas")
      .forEach(initCanvas);
  }

  function cleanup() {
    canvasStates.forEach((state) => {
      if (state.animationId) cancelAnimationFrame(state.animationId);
      state.resizeObserver.disconnect();
    });
    canvasStates.clear();
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initAllCanvases);
  } else {
    initAllCanvases();
  }
  document.addEventListener("astro:after-swap", initAllCanvases);
  document.addEventListener("astro:before-swap", cleanup, { once: true });
</script>

<style>
  .app-development-canvas {
    display: block;
  }
</style>

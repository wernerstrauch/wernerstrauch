---
interface Props {
  lineCount?: number;
  amplitude?: number;
  frequency?: number;
  speed?: number;
  verticalSpacing?: number;
  rotation?: number;
  magnetStrength?: number;
  magnetRadius?: number;
  leaderSpeed?: number;
  colors?: string[];
  showCursor?: boolean;
}

const {
  lineCount = 80,
  amplitude = 100,
  frequency = 0.002,
  speed = 0.003,
  verticalSpacing = 9,
  rotation = -10,
  magnetStrength = 300,
  magnetRadius = 350,
  leaderSpeed = 0.02,
  colors = ["#00FFFF", "#FFD700", "#39FF14"],
  showCursor = false,
} = Astro.props;

const configJson = JSON.stringify({
  lineCount,
  amplitude,
  frequency,
  speed,
  verticalSpacing,
  rotation,
  magnetStrength,
  magnetRadius,
  leaderSpeed,
  colors,
  showCursor,
});
---

<div class="magnetic-field-background absolute inset-0 overflow-hidden">
  <canvas
    id="magnetic-field-canvas"
    class="magnetic-field-canvas absolute inset-0 h-full w-full"></canvas>
</div>

<script define:vars={{ configJson }}>
  window.__magneticFieldConfig = JSON.parse(configJson);
</script>

<script>
  function initMagneticField() {
    const canvas = document.getElementById(
      "magnetic-field-canvas",
    ) as HTMLCanvasElement;
    if (!canvas) return;

    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const userConfig = (window as any).__magneticFieldConfig || {};

    const CONFIG = {
      lineCount: userConfig.lineCount || 80,
      amplitude: userConfig.amplitude || 100,
      frequency: userConfig.frequency || 0.002,
      speed: userConfig.speed || 0.003,
      verticalSpacing: userConfig.verticalSpacing || 9,
      rotation: userConfig.rotation || -10,
      magnetStrength: userConfig.magnetStrength || 300,
      magnetRadius: userConfig.magnetRadius || 350,
      leaderSpeed: userConfig.leaderSpeed || 0.02,
      colors: userConfig.colors || ["#00FFFF", "#FFD700", "#39FF14"],
      showCursor: userConfig.showCursor !== false,
    };

    let width = 0;
    let height = 0;
    let time = 0;
    let animationId: number;
    let isVisible = true;
    let hasRenderedFirstFrame = false;

    const mouse = { x: -1000, y: -1000, active: false };
    const leader = { x: 0, y: 0 };

    function lerp(start: number, end: number, factor: number): number {
      return start + (end - start) * factor;
    }

    function getRotatedPoint(
      x: number,
      y: number,
      cx: number,
      cy: number,
      angleDeg: number,
    ): { x: number; y: number } {
      const rad = -angleDeg * (Math.PI / 180);
      const dx = x - cx;
      const dy = y - cy;
      return {
        x: cx + (dx * Math.cos(rad) - dy * Math.sin(rad)),
        y: cy + (dx * Math.sin(rad) + dy * Math.cos(rad)),
      };
    }

    function updateMouse(clientX: number, clientY: number) {
      const rect = canvas.getBoundingClientRect();
      const isInBounds =
        clientX >= rect.left &&
        clientX <= rect.right &&
        clientY >= rect.top &&
        clientY <= rect.bottom;

      mouse.x = clientX - rect.left;
      mouse.y = clientY - rect.top;
      mouse.active = isInBounds;
    }

    const handleMouseMove = (e: MouseEvent) => {
      updateMouse(e.clientX, e.clientY);
    };

    const handleTouchMove = (e: TouchEvent) => {
      updateMouse(e.touches[0].clientX, e.touches[0].clientY);
    };

    window.addEventListener("mousemove", handleMouseMove);
    window.addEventListener("touchmove", handleTouchMove, { passive: true });

    function updateSize() {
      const container = canvas.parentElement;
      if (!container) return;

      const rect = container.getBoundingClientRect();
      const w = Math.floor(rect.width);
      const h = Math.floor(rect.height);

      if (w === 0 || h === 0) return;
      if (w === width && h === height) return;

      width = w;
      height = h;

      const dpr = Math.min(window.devicePixelRatio, 2);
      canvas.width = w * dpr;
      canvas.height = h * dpr;
      canvas.style.width = w + "px";
      canvas.style.height = h + "px";
      ctx!.scale(dpr, dpr);

      if (!mouse.active) {
        mouse.x = width / 2;
        mouse.y = height / 2;
        leader.x = width / 2;
        leader.y = height / 2;
      }
    }

    function createGradient(): CanvasGradient {
      const gradient = ctx!.createLinearGradient(0, 0, width, height);
      const colors = CONFIG.colors;
      const step = 1 / (colors.length - 1);

      colors.forEach((color: string, i: number) => {
        gradient.addColorStop(Math.min(i * step, 1), color);
      });

      return gradient;
    }

    function animate() {
      animationId = requestAnimationFrame(animate);

      if (!isVisible) return;

      const dpr = Math.min(window.devicePixelRatio, 2);
      ctx!.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx!.clearRect(0, 0, width, height);

      const gradient = createGradient();
      ctx!.lineWidth = 1.2;
      ctx!.strokeStyle = gradient;
      ctx!.globalAlpha = 0.8;

      // When mouse is active, follow it. When inactive, leader stays at last position
      if (mouse.active) {
        leader.x = lerp(leader.x, mouse.x, CONFIG.leaderSpeed);
        leader.y = lerp(leader.y, mouse.y, CONFIG.leaderSpeed);
      }
      // else: leader stays at current position (no movement)

      // Transform leader to rotated coordinate system
      const rotCenter = { x: width / 2, y: height / 2 };
      const rotLeader = getRotatedPoint(
        leader.x,
        leader.y,
        rotCenter.x,
        rotCenter.y,
        CONFIG.rotation,
      );

      // Apply canvas rotation
      ctx!.save();
      ctx!.translate(rotCenter.x, rotCenter.y);
      ctx!.rotate((CONFIG.rotation * Math.PI) / 180);
      ctx!.translate(-rotCenter.x, -rotCenter.y);

      const extraMargin = 300;
      const blockHeight = CONFIG.lineCount * CONFIG.verticalSpacing;
      const blockTop = height / 2 - blockHeight / 2;

      // Draw wave lines
      for (let i = 0; i < CONFIG.lineCount; i++) {
        ctx!.beginPath();

        const yBase = blockTop + i * CONFIG.verticalSpacing;
        let firstPoint = true;

        for (let x = -extraMargin; x < width + extraMargin; x += 15) {
          // Wave calculation
          const wave1 = Math.sin(x * CONFIG.frequency + time + i * 0.07);
          const wave2 = Math.sin(
            x * (CONFIG.frequency * 2.5) + time * 1.3 + i * 0.05,
          );
          let y =
            yBase +
            (wave1 * CONFIG.amplitude + wave2 * (CONFIG.amplitude * 0.3));

          // Magnetic interaction
          const dx = x - rotLeader.x;
          const dy = yBase - rotLeader.y;
          const distSq = dx * dx + dy * dy;

          if (distSq < CONFIG.magnetRadius * CONFIG.magnetRadius) {
            const dist = Math.sqrt(distSq);
            const force =
              Math.cos((dist / CONFIG.magnetRadius) * (Math.PI / 2)) *
              CONFIG.magnetStrength;

            const shift = ((rotLeader.y - yBase) * force) / 1000;
            y += shift * 2;

            // Add local energy ripple
            y += Math.sin(dist * 0.05 - time * 5) * (force * 0.05);
          }

          if (firstPoint) {
            ctx!.moveTo(x, y);
            firstPoint = false;
          } else {
            ctx!.lineTo(x, y);
          }
        }
        ctx!.stroke();
      }

      ctx!.restore();

      // Draw cursor visualization
      if (CONFIG.showCursor) {
        ctx!.shadowBlur = 20;
        ctx!.shadowColor = "white";

        ctx!.beginPath();
        ctx!.arc(leader.x, leader.y, 4, 0, Math.PI * 2);
        ctx!.fillStyle = "#fff";
        ctx!.fill();

        ctx!.shadowBlur = 0;
        ctx!.beginPath();
        const ringSize = 15 + Math.sin(time * 10) * 2;
        ctx!.arc(leader.x, leader.y, ringSize, 0, Math.PI * 2);
        ctx!.strokeStyle = "rgba(255, 255, 255, 0.5)";
        ctx!.lineWidth = 1;
        ctx!.stroke();
      }

      time += CONFIG.speed;

      if (!hasRenderedFirstFrame) {
        hasRenderedFirstFrame = true;
        canvas.classList.add("is-ready");
      }
    }

    const resizeObserver = new ResizeObserver(() => {
      requestAnimationFrame(() => {
        updateSize();
      });
    });

    const observeTarget = canvas.parentElement || canvas;
    resizeObserver.observe(observeTarget);

    window.addEventListener("resize", updateSize);

    const visibilityObserver = new IntersectionObserver(
      (entries) => {
        isVisible = entries[0].isIntersecting;
      },
      { threshold: 0 },
    );
    visibilityObserver.observe(canvas);

    updateSize();
    animationId = requestAnimationFrame(animate);

    document.addEventListener(
      "astro:before-swap",
      () => {
        cancelAnimationFrame(animationId);
        resizeObserver.disconnect();
        visibilityObserver.disconnect();
        window.removeEventListener("mousemove", handleMouseMove);
        window.removeEventListener("touchmove", handleTouchMove);
        window.removeEventListener("resize", updateSize);
      },
      { once: true },
    );
  }

  function deferredInit() {
    if ("requestIdleCallback" in window) {
      requestIdleCallback(() => initMagneticField(), { timeout: 2000 });
    } else {
      setTimeout(initMagneticField, 100);
    }
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", deferredInit);
  } else {
    deferredInit();
  }
  document.addEventListener("astro:after-swap", deferredInit);
</script>

<style>
  @reference "../../styles/styles.css";

  .magnetic-field-background {
    background: var(--color-zinc-900);
  }

  .magnetic-field-canvas {
    opacity: 0;
    transition: opacity 0.5s ease-out;
  }

  .magnetic-field-canvas.is-ready {
    opacity: 1;
  }
</style>

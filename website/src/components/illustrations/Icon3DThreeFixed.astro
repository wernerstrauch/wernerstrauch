---
interface Props {
  variant?: "light" | "dark";
  icon?: "meta" | "google-ads" | "shopify" | "klaviyo";
}

const { variant = "light", icon = "meta" } = Astro.props;
const uniqueId = `three-${icon}-${Math.random().toString(36).substring(2, 9)}`;

// Icon Konfigurationen
const iconConfigs = {
  "meta": { color: "#0081FB" },
  "google-ads": { color: "#4285F4" },
  "shopify": { color: "#96BF48" },
  "klaviyo": { color: "#000000" }
};

const config = iconConfigs[icon];
---

<div class="absolute inset-0 overflow-hidden pointer-events-none flex items-center justify-center" data-variant={variant}>
  <canvas id={uniqueId} class="w-full h-full" data-icon={icon} data-color={config.color}></canvas>
</div>

<script>
  import * as THREE from 'three';

  function initIcon(canvas: HTMLCanvasElement) {
    const icon = canvas.dataset.icon || 'meta';
    const iconColor = canvas.dataset.color || '#0081FB';

    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
    camera.position.z = 5;

    const renderer = new THREE.WebGLRenderer({
      canvas: canvas,
      alpha: true,
      antialias: true
    });
    renderer.setSize(canvas.clientWidth, canvas.clientHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight1.position.set(5, 5, 5);
    scene.add(directionalLight1);

    const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
    directionalLight2.position.set(-5, -5, -5);
    scene.add(directionalLight2);

    // Create 3D object
    const iconGroup = new THREE.Group();

    if (icon === 'meta') {
      // Meta - Simple "M" shape
      const shape = new THREE.Shape();
      shape.moveTo(-1, -1);
      shape.lineTo(-0.6, 1);
      shape.lineTo(-0.2, -0.5);
      shape.lineTo(0.2, 1);
      shape.lineTo(0.6, -1);
      shape.lineTo(0.3, -1);
      shape.lineTo(0.2, 0.3);
      shape.lineTo(0, -0.3);
      shape.lineTo(-0.2, 0.3);
      shape.lineTo(-0.3, -1);
      shape.lineTo(-1, -1);

      const geometry = new THREE.ExtrudeGeometry(shape, {
        depth: 0.4,
        bevelEnabled: true,
        bevelThickness: 0.1,
        bevelSize: 0.05,
        bevelSegments: 5
      });

      const material = new THREE.MeshStandardMaterial({
        color: new THREE.Color(iconColor),
        metalness: 0.3,
        roughness: 0.4
      });

      const mesh = new THREE.Mesh(geometry, material);
      iconGroup.add(mesh);

    } else if (icon === 'google-ads') {
      // Google Ads - "G" shape
      const torusGeometry = new THREE.TorusGeometry(1, 0.3, 16, 100, Math.PI * 1.5);
      const material = new THREE.MeshStandardMaterial({
        color: new THREE.Color(iconColor),
        metalness: 0.3,
        roughness: 0.4
      });
      const torus = new THREE.Mesh(torusGeometry, material);
      torus.rotation.z = Math.PI * 0.25;
      iconGroup.add(torus);

      const barGeometry = new THREE.BoxGeometry(1.2, 0.3, 0.3);
      const bar = new THREE.Mesh(barGeometry, material);
      bar.position.set(0.3, 0, 0);
      iconGroup.add(bar);

    } else if (icon === 'shopify') {
      // Shopify - Shopping bag
      const shape = new THREE.Shape();
      shape.moveTo(-0.8, 0.5);
      shape.lineTo(-1, -1);
      shape.lineTo(1, -1);
      shape.lineTo(0.8, 0.5);
      shape.lineTo(-0.8, 0.5);

      const geometry = new THREE.ExtrudeGeometry(shape, {
        depth: 0.5,
        bevelEnabled: true,
        bevelThickness: 0.08,
        bevelSize: 0.05,
        bevelSegments: 3
      });

      const material = new THREE.MeshStandardMaterial({
        color: new THREE.Color(iconColor),
        metalness: 0.2,
        roughness: 0.5
      });

      const bag = new THREE.Mesh(geometry, material);
      iconGroup.add(bag);

      const handleGeometry = new THREE.TorusGeometry(0.5, 0.1, 8, 32, Math.PI);
      const handle = new THREE.Mesh(handleGeometry, material);
      handle.rotation.z = Math.PI;
      handle.position.y = 0.5;
      handle.position.z = 0.25;
      iconGroup.add(handle);

    } else if (icon === 'klaviyo') {
      // Klaviyo - Envelope
      const shape = new THREE.Shape();
      shape.moveTo(-1, -0.6);
      shape.lineTo(1, -0.6);
      shape.lineTo(1, 0.6);
      shape.lineTo(-1, 0.6);
      shape.lineTo(-1, -0.6);

      const geometry = new THREE.ExtrudeGeometry(shape, {
        depth: 0.2,
        bevelEnabled: true,
        bevelThickness: 0.05,
        bevelSize: 0.03,
        bevelSegments: 2
      });

      const material = new THREE.MeshStandardMaterial({
        color: new THREE.Color(iconColor),
        metalness: 0.4,
        roughness: 0.3
      });

      const envelope = new THREE.Mesh(geometry, material);
      iconGroup.add(envelope);
    }

    scene.add(iconGroup);

    // Animation
    let mouseX = 0;
    let mouseY = 0;

    canvas.addEventListener('mousemove', (event) => {
      const rect = canvas.getBoundingClientRect();
      mouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouseY = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    });

    function animate() {
      requestAnimationFrame(animate);

      const targetRotationY = mouseX * 0.5;
      const targetRotationX = mouseY * 0.5;

      iconGroup.rotation.y += (targetRotationY - iconGroup.rotation.y) * 0.05;
      iconGroup.rotation.x += (targetRotationX - iconGroup.rotation.x) * 0.05;

      iconGroup.rotation.y += 0.003;
      iconGroup.position.y = Math.sin(Date.now() * 0.001) * 0.1;

      renderer.render(scene, camera);
    }

    animate();

    // Resize handler
    const resizeObserver = new ResizeObserver(() => {
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(canvas.clientWidth, canvas.clientHeight);
    });

    resizeObserver.observe(canvas);

    return () => {
      resizeObserver.disconnect();
      renderer.dispose();
    };
  }

  // Initialize all canvases
  function initAllIcons() {
    const canvases = document.querySelectorAll<HTMLCanvasElement>('canvas[data-icon]');
    const cleanups: (() => void)[] = [];

    canvases.forEach(canvas => {
      const cleanup = initIcon(canvas);
      if (cleanup) cleanups.push(cleanup);
    });

    return cleanups;
  }

  // Initialize on load
  let cleanups: (() => void)[] = [];

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      cleanups = initAllIcons();
    });
  } else {
    cleanups = initAllIcons();
  }

  // Cleanup on page transition
  document.addEventListener('astro:before-swap', () => {
    cleanups.forEach(cleanup => cleanup());
  });

  // Re-initialize on page load
  document.addEventListener('astro:page-load', () => {
    cleanups = initAllIcons();
  });
</script>

<style>
  canvas {
    display: block;
  }
</style>
